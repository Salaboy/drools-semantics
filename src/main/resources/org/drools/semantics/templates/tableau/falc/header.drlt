@declare{'FALC_header'}

package org.drools.semantics.lang.dl;


import net.sf.javailp.*; 
import java.util.Arrays;
import net.sf.javailp.Problem;
import java.util.*;
import net.sf.javailp.Solver;
import net.sf.javailp.Problem;
import net.sf.javailp.SolverFactoryGLPK;
import org.drools.KnowledgeBase;
import java.util.List;
import org.drools.runtime.StatefulKnowledgeSession;
import net.sf.javailp.Result;
import net.sf.javailp.Solver;



// All tableau rules have negative salience!

global Solver solver;


function Object initProblem(Problem prob) {
	// Target : minimize X
	// 1-X is the NECessity of neg C	(C is the target class)
	// min X <=> maximize NEC --C
	// NEC --C <==> 1 - POSsibility of C
	// so, minimizing POS C
	// which is the best value for NEC C 	
	Object X = ConstraintFactory.newUnitIntervalVariable("X",prob);
	Linear objective = ConstraintFactory.buildLinear( " 1.0*" + X );
	prob.setOptimizationType(OptType.MIN);
	prob.setObjective(objective);
	
	// can't have a degree with 1-X ?
	// just switch : nX == 1 - X
	Object Xneg = ConstraintFactory.newUnitIntervalVariable("nX",prob);
	ConstraintFactory.addComplementConstraint(X,Xneg,prob);	
	return Xneg;
}

query "q_mock" ( String mid )
	$m : Mock ( id == mid)
end

query "q_subsumption" ( String sub, String sup )
	$sc : SubClassOf( subject == sub , object == sup )
	Degree( subject == $sc , $tau : tau , $phi : phi )
end

query "q_subsumptionAll" (  )
	$sc : SubClassOf( $sub : subject , $sup : object )
	Degree( subject == $sc , $tau : tau , $phi : phi )
end

query "q_recognition" ( Object o, String klass )
	$type : Type( subject == o , object == klass )
	Degree( subject == $type , $tau : tau , $phi : phi )
end





rule "Init_Recognition_Problem"
//agenda-group "Tableau"
salience -2
when
	$test : RecognitionTest( $subj : subject != null, $klass : targetClass, 
							 $prob : problem , $tau : tau  )
then
	System.out.println("About to solve rec goal : " + $test);
	
	Object Xneg = initProblem($prob);
	
	HypoType type = new HypoType($subj, $klass, $tau, $test);	//negated!
	Degree deg = new Degree(type, Xneg );
	
//	System.out.println(type.toFullString());
//	System.out.println(deg);
	
	insertLogical(deg);
	insertLogical(type);
			
end




rule "Init_Subsumption_Problem"
//agenda-group "Tableau"
salience -2
when
	$test : SubsumptionTest( $sub : subClass, $sup : superClass != $sub, 
							 $prob : problem , $tau : tau )
then
	System.out.println("About to solve sub goal : " + $test);
	
	Object Xneg = initProblem($prob);
	Mock mock = new Mock("M");
	
	
	HypoType typeA = new HypoType(mock, $sub, false, $test);	//positive!?
	HypoType typeB = new HypoType(mock, $sup, false, $test);	//positive!?	
	
	Object xB = ConstraintFactory.newBooleanVariable("x_"+typeB.getLabel(),$prob);
	Object xA = ConstraintFactory.newBooleanVariable("x_"+typeA.getLabel(),$prob);
		
	System.out.println(xA + " vs " + xB + " // " + $tau);
	
	Constraint c;
		if ($tau) {
			ConstraintFactory.addImplicationConstraint(xA,xB,Xneg,$prob);
		} else {
		    Object xNA = ConstraintFactory.newBooleanVariable("xN_"+typeA.getLabel(),$prob);
		    ConstraintFactory.addComplementConstraint(xA,xNA,$prob);
		 	ConstraintFactory.addImplicationConstraint(xB,xNA,Xneg,$prob);
		}
	
	Degree degA = new Degree(typeA, xA );
	Degree degB = new Degree(typeB, xB );
	
	insertLogical(typeA);
	insertLogical(degA);
	insertLogical(typeB);
	insertLogical(degB);
	
			
end


rule "Init_Trivial_Subsumption_Problem"
//agenda-group "Tableau"
salience -2
when
	$test : SubsumptionTest( $sub : subClass, $sup : superClass == $sub )
then
	retract($test);
	SubClassOf sc = new SubClassOf($sub,$sup);	
	Degree deg = new Degree(sc,1.0,1.0);
		
	insert(sc);
	insert(deg);	
end






rule "Type"
salience -10
when
	$test : RecognitionTest( $subj : subject, $klass : targetClass, $prob : problem )
	$type : HypoType( goal == $test , $xlab : label , $s : subject , $o : object, negated==false)	
	$degr : Degree( subject == $type , $l : value != null ) 
then
//	System.out.println(" Rule Type 1 " + $l);
		
	Object x = ConstraintFactory.newUnitIntervalVariable("x_"+$xlab,$prob);
	if (! x.equals($l)) {
		ConstraintFactory.addLBConstraint(x,$l,$prob);
	}
end
 

rule "Type_Neg"
//agenda-group "Tableau"
salience -20
when
	$test : DLTest( $prob : problem )
	$type : HypoType( goal == $test , $xlab : label , negated == true )
	$degr : Degree( subject == $type , $l : value != null )
then
//	System.out.println(" Rule Type 2 : --A" + $type + " // " + $l);
		
	Object x = ConstraintFactory.newUnitIntervalVariable("x_"+$xlab,$prob);
	if (! x.equals($l)) {
		ConstraintFactory.addUBConstraint(x,$l,$prob);		
	}
end





rule "Type_Collect"
//agenda-group "Tableau"
salience -10
when
	$test : DLTest( $prob : problem )
	$type : HypoType( goal == $test , $xlab : label , $s : subject , $o : object, $neg : negated )
	$oldT : Type( subject == $s , object == $o )
	$oldD : Degree( subject == $oldT , $tau : tau != null, $phi : phi != null ) 
then
	System.out.println(" Rule Type 1 , recover data " + $oldT + " bound " +$tau + " : " + $phi);
	if ($phi - $tau < 1e-6) {	
		// due to imperfect roundings, tau may seem to be > phi when they are actually ==
		$tau = $tau - 1e-6;
	}	
		
	Object v1 = ConstraintFactory.newUnitIntervalVariable("nX_"+$xlab,1.0-$phi,1.0-$tau,$prob);
	Object v2 =	ConstraintFactory.newUnitIntervalVariable("x_"+$xlab,$tau,$phi,$prob);
	ConstraintFactory.addComplementConstraint(v2,v1,$prob);

end



rule "Property_Collect"
//agenda-group "Tableau"
salience -50
when
	$test : DLTest( $prob : problem )
	$prop : HypoProperty( goal == $test , $xlab : label , $s : subject , $p : predicate , $o : object )
	$oldP : Property( subject == $s , object == $o , predicate == $p )
	$oldD : Degree( subject == $oldP , $tau : tau != null, $phi : phi != null )	
then
	System.out.println(" Rule Type 5 (R), recover data " + $oldP + " bound " + $tau + " : " + $phi);
		
	ConstraintFactory.newUnitIntervalVariable("x_"+$xlab, $tau, $phi, $prob);
end




 









rule "Cleanup_Sub"
//agenda-group "Solver"
salience -200
when 
	$test : SubsumptionTest( $sub : subClass , $sup : superClass , 
							 $p : problem , $tau :tau )
then
//	System.out.println("\n\n");
//	System.out.println("-----------------------------------------------------------");
//	System.out.println($p);
//	System.out.println("-----------------------------------------------------------");

	Result res = solver.solve($p);
    if (res == null) {
        System.out.println("ERROR" + $p);
    	System.exit(-44);
    	}
	Number x = res.getObjective();

//	System.out.println(res);
//	System.out.println("-----------------------------------------------------------" +$sub + " vs " + $sup );

	SubClassOf sc = new SubClassOf($sub,$sup);
	Degree deg;
	if ($tau == true) {
		deg = new Degree(sc,x.doubleValue(),1.0);
	} else {
	    deg = new Degree(sc,0.0,1.0-x.doubleValue());
//		deg = new Degree(sc,0.0,x.doubleValue());
    }



	insert(sc);
	insert(deg);

	retract($test);
end



rule "Cleanup_Rec"
//agenda-group "Solver"
salience -200
when 
	$test : RecognitionTest( $sub : subject , $tgt : targetClass , 
							 $p : problem , $tau :tau )
then
//	System.out.println("\n\n");
//	System.out.println("-----------------------------------------------------------");
//	System.out.println($p);
//	System.out.println("-----------------------------------------------------------");

	Result res = solver.solve($p);
	
	
//	System.out.println(res);
//	System.out.println("-----------------------------------------------------------");
	
	Number x = res.getObjective();
	Type type = new Type($sub,$tgt);
	Degree deg;
	if ($tau == true)
		deg = new Degree(type,x.doubleValue(),1.0);
	else	
		deg = new Degree(type,0.0,1.0-x.doubleValue());



	insert(type);
	insert(deg);
	
	
	retract($test);
end





rule "Merge"
when
	$t : Type()
	$d1 : Degree( subject == $t, $tau1 : tau, $phi1 : phi )
	$d2 : Degree( subject == $t, this != $d1, $tau2 : tau, $phi2 : phi)
then
	$d1.setTau(Math.max($tau1,$tau2));
	$d1.setPhi(Math.min($phi1,$phi2));
	retract($d2);
end

rule "Merge2"
when
	$t : SubClassOf( )
	$d1 : Degree( subject == $t, $tau1 : tau, $phi1 : phi )
	$d2 : Degree( subject == $t, this != $d1, $tau2 : tau, $phi2 : phi)
then
	$d1.setTau(Math.max($tau1,$tau2));
	$d1.setPhi(Math.min($phi1,$phi2));
	retract($d2);
end

@end{}

@includeNamed{'FALC_header'}


